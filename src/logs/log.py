from datetime import datetime
import sqlite3
import os
from security.encryption import load_symmetric_key, encrypt_message, decrypt_message



class LogFunction():
    def __init__(self):
        self.db = None
        self.cursor = None
    
    def openConnection(self):
        if self.db is None:

            base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            db_path = os.path.join(base_dir, 'data', 'urban_mobility.db')

            self.db = sqlite3.connect(db_path)
            self.cursor = self.db.cursor()

    def closeConnection(self):
        if self.db is not None:
            self.cursor.close()
            self.db.close()
            self.db = None
            self.cursor = None

    #addlog
    def addlog(self, username=None, action=None, details=None, suspicious=None):

        key = load_symmetric_key()

        
        # log entry in the database expects the following inputs:
            # date
            # username (if any)
            # action (where does the log originate from, ie: "login", "logout", "update", etc.)
            # details (additional information about what went wrong during the action)
            # suspicious (boolean, if the action is suspicious or not)
        # It does NOT expect an ID, and those are auto-generated by the database
        
        # Assign default values only if None is given
        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        username = username if username else "No username was given"
        action = action if action else "No action was given"
        details = details if details else "No additional info was given"
        suspicious = "True" if suspicious == True else "False" if suspicious == False else "No action indicator was given"

        self.openConnection()
        try:
            query = """ 
            INSERT INTO logs (date, username, action, details, suspicious) VALUES (?, ?, ?, ?, ?)
            """

            self.cursor.execute(query,(now, encrypt_message(username, key), encrypt_message(action, key), encrypt_message(details, key), encrypt_message(suspicious, key) ))
            self.db.commit()

        except sqlite3.Error as e:
            print(f"An error occurred: {e}")

        finally:
            self.closeConnection()

    def log_invalid_input(self, username, field, reason, suspicious=False):
        action = f"Invalid input for {field}"
        details = f"Reason: {reason}"
        self.addlog(username=username, action=action, details=details, suspicious=suspicious)
    
    def show_logs(self, current_user):
        """Toon alle logs met decryptie van versleutelde velden."""
            
        self.openConnection()
        key = load_symmetric_key()  # Load the symmetric key for decryption
        
        try:
            self.cursor.execute('SELECT id, Date, username, action, details, suspicious FROM logs ORDER BY date DESC')
            rows = self.cursor.fetchall()
            
            if not rows:
                print("No logs found.")
                return
                
            print("\n--- System Logs ---")
            print(f"{'ID':<5} {'Date':<20} {'Username':<15} {'Action':<35} {'Details':<35} {'Suspicious':<10}")
            print("-" * 100)
            
            for row in rows:
                log_id = row[0]
                date = row[1]  # Timestamp is usually not encrypted

                # Decrypt the fields that are encrypted
                username = decrypt_message(row[2], key) if row[2] else "N/A"
                action = decrypt_message(row[3], key) if row[3] else "N/A"
                details = decrypt_message(row[4], key) if row[4] else "N/A"

                # Suspicious is often a boolean or integer

                suspicious = "Yes" if decrypt_message(row[5], key)  == "True" else "No"

                # Limit the length of fields for neat alignment
                username = username[:15]
                action = action[:35]
                details = details[:50]

                print(f"{log_id:<5} {date:<20} {username:<15} {action:<35} {details:<50} {suspicious:<10}")

            print("-" * 100)
            
        except Exception as e:
            print(f"An error occurred while retrieving logs: {e}")
        finally:
            self.closeConnection()


    def show_suspicious_logs(self, current_user):

        # Ask if the user wants to view the logs
        view_logs = input("There are unread suspicious logs that require your attention. Would you like to view them now? (y/n): ").strip().lower()
        
        if view_logs != 'y' and view_logs != 'yes':
            print("You can review the suspicious logs later.")
            return

        # afterwards it will look for logs in the database that are both marked as suspicious AND are unread
        self.openConnection()
        key = load_symmetric_key()
        try:
        # Retrieve all logs to filter them after decryption
            self.cursor.execute('SELECT id, Date, username, action, details, suspicious, is_read FROM logs ORDER BY date DESC')
            rows = self.cursor.fetchall()

            # Filter the logs where suspicious after decryption is "True"
            unread_suspicious_logs = []
            for row in rows:
                suspicious_value = decrypt_message(row[5], key)
                is_read = row[6]

                if suspicious_value == "True" and is_read == 0:
                    unread_suspicious_logs.append(row)

            if not unread_suspicious_logs:
                print("No unread suspicious logs found.")
                return

            print("\n--- Unread Suspicious Logs ---")
            print(f"{'ID':<5} {'Date':<20} {'Username':<15} {'Action':<35} {'Details':<50}")
            print("-" * 100)

            for row in unread_suspicious_logs:
                log_id = row[0]
                date = row[1]  # Timestamp is usually not encrypted
                username = decrypt_message(row[2], key) if row[2] else "N/A"
                action = decrypt_message(row[3], key) if row[3] else "N/A"
                details = decrypt_message(row[4], key) if row[4] else "N/A"

                # Limit the length of fields for neat alignment
                username = username[:15]
                action = action[:35]
                details = details[:50]

                print(f"{log_id:<5} {date:<20} {username:<15} {action:<35} {details:<50}")

            print("-" * 100)
            
            mark_as_read = input("Do you want to mark these logs as read? (y/n): ").strip().lower()
        
            if mark_as_read == 'y' or mark_as_read == 'yes':
                # Mark the logs as read
                log_ids = [row[0] for row in unread_suspicious_logs]

                # Update the logs with placeholders for each ID
                placeholders = ', '.join(['?' for _ in log_ids])
                update_query = f"UPDATE logs SET is_read = 1 WHERE id IN ({placeholders})"
                
                self.cursor.execute(update_query, log_ids)
                self.db.commit()
                
                print(f"Successfully marked {len(log_ids)} logs as read.")

                # Log this action
                self.addlog(
                    username=current_user.username, 
                    action="Marked logs as read", 
                    details=f"Administrator marked {len(log_ids)} suspicious logs as read",
                    suspicious=False
                )
            else:
                print("Logs remain marked as unread.")

        except Exception as e:
            print(f"An error occurred while retrieving suspicious logs: {e}")
        finally:
            self.closeConnection()


    def check_for_suspicious_logs(self, current_user):
        """Checks for suspicious unread logs and returns true if any are found, false otherwise."""
        # Check if the user is authorized to view logs
        
        self.openConnection()
        key = load_symmetric_key()  # Load the symmetric key for decryption

        try:
            # Retrieve all logs to filter after decryption
            self.cursor.execute('SELECT id, Date, username, action, details, suspicious, is_read FROM logs ORDER BY date DESC')
            rows = self.cursor.fetchall()
            
            # Filter logs where suspicious after decryption is "True" and is_read is 0
            for row in rows:
                suspicious_value = decrypt_message(row[5], key)
                is_read = row[6]

                if suspicious_value == "True" and is_read == 0:
                    return True  # Suspicious unread log found

            return False
        except Exception as e:
            print(f"An error occurred while checking for suspicious logs: {e}")
            return False
        finally:
            self.closeConnection()
            
# Create an instance of LogFunction to use in other modules
log_instance = LogFunction()


